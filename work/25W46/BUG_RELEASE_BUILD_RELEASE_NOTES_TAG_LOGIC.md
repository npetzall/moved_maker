# Implementation Plan: BUG_RELEASE_BUILD_RELEASE_NOTES_TAG_LOGIC

**Status**: ‚úÖ Complete

## Overview

This implementation plan addresses the bug described in `plan/25W46/BUG_RELEASE_BUILD_RELEASE_NOTES_TAG_LOGIC.md`.

## Context

Related bug report: `plan/25W46/BUG_RELEASE_BUILD_RELEASE_NOTES_TAG_LOGIC.md`

## Solution: Python Application with PyGitHub

Given that commits should follow Conventional Commits format and we'll want to add more processing in the future (parsing, categorization, formatting), we'll create a Python application similar to `release-version`. This approach will:

1. Fix the tag comparison issue by correctly identifying the previous tag
2. Enable parsing of Conventional Commits for better categorization
3. Generate well-structured **Markdown** release notes with rich formatting
4. Provide structured, maintainable code that's easy to test and extend
5. Use PyGitHub for better structured data and GitHub integration

The release notes will be generated in **Markdown format** and can be enhanced with:
- **Application and Other sections**: Split commits into "Application" (modifies `src/`, `Cargo.toml`, `Cargo.lock`) and "Other" sections, matching the logic used in `release-version` workflow
- Categorized sections (Features, Bug Fixes, Breaking Changes, etc.) within each main section
- Links to commits, PRs, and issues
- Author attribution
- Emoji indicators for different change types
- Structured formatting with proper headings and lists
- Installation instructions and download links

### Project Structure

Create a new Python project using `uv` in `.github/scripts/release-notes/`:

```
.github/scripts/release-notes/
‚îú‚îÄ‚îÄ pyproject.toml          # Project metadata and dependencies (uv project)
‚îú‚îÄ‚îÄ uv.lock                 # Dependency lock file (generated by uv)
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ release_notes/
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ __main__.py     # Entry point
‚îÇ       ‚îú‚îÄ‚îÄ git.py          # Git operations (tags, commits)
‚îÇ       ‚îú‚îÄ‚îÄ parser.py        # Conventional Commits parsing
‚îÇ       ‚îî‚îÄ‚îÄ formatter.py    # Release notes formatting
‚îî‚îÄ‚îÄ tests/
    ‚îú‚îÄ‚îÄ __init__.py
    ‚îú‚îÄ‚îÄ conftest.py
    ‚îú‚îÄ‚îÄ test_git.py
    ‚îú‚îÄ‚îÄ test_parser.py
    ‚îî‚îÄ‚îÄ test_formatter.py
```

### Why PyGitHub?

We'll use PyGitHub instead of Git CLI for the following reasons:

**PyGitHub Capabilities:**
- `repo.get_tags()` - Get all tags, sorted by creation date
- `repo.compare(base_sha, head_sha)` - Get commits between two SHAs
- `commit.commit.message` - Full commit message (subject + body)
- `commit.commit.author` - Author information
- `commit.sha` - Commit SHA
- `commit.html_url` - Link to commit on GitHub

**Benefits:**
1. **Structured Data**: Commit objects provide rich metadata (author, date, message, URL)
2. **Path Filtering**: Uses git CLI for efficient path filtering (matching `release-version` logic)
3. **Better Commit Messages**: Access to full commit message (subject + body), not just subject
4. **GitHub Integration**: Can link to commits, PRs, and issues directly
5. **Rate Limits**: GitHub Actions tokens have 1,000 requests/hour per repository (sufficient for this use case)
6. **Consistency**: Matches `release-version` path filtering logic (`src/`, `Cargo.toml`, `Cargo.lock`)
7. **Tag Metadata**: Access to tag creation date, tagger, and tag message
8. **Future Extensibility**: Easier to parse Conventional Commits from structured commit objects
9. **Rich Formatting**: Can include links, authors, and PR references
10. **Clear Separation**: Application changes vs. other changes (docs, workflows, etc.)

**Implementation Example:**
```python
from github import Auth, Github
from packaging import version

def get_tags_sorted(repo):
    """Get tags sorted by version (descending)."""
    tags = list(repo.get_tags())
    # Sort by semantic version
    tags.sort(key=lambda t: version.parse(t.name.lstrip('v')), reverse=True)
    return tags

def get_commits_between_tags(repo, previous_tag, current_tag):
    """Get commits between two tags."""
    # Use compare API to get commits between two SHAs
    comparison = repo.compare(previous_tag.commit.sha, current_tag.commit.sha)
    return comparison.commits  # Returns list of Commit objects
```

### Project Setup with `uv`

**Initialize Project:**
```bash
cd .github/scripts
uv init release-notes
cd release-notes
```

**Add Dependencies:**
```bash
# Core dependencies
uv add pygithub packaging

# Development dependencies
uv add --dev pytest pytest-datadir
```

**pyproject.toml Structure:**
```toml
[project]
name = "release-notes"
version = "0.1.0"
requires-python = ">=3.11"
dependencies = [
    "pygithub>=2.0.0",
    "packaging>=24.0",
]

[project.optional-dependencies]
dev = [
    "pytest>=8.0.0",
    "pytest-datadir>=1.4.0",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
```

### Implementation Plan

#### Phase 1: Core Git Operations (`git.py`)
- `get_tags_sorted(repo)` - Get tags sorted by semantic version
- `get_previous_tag(repo, current_tag_name)` - Get previous tag
- `get_commits_between_tags(repo, previous_tag, current_tag)` - Get commits
- `get_all_commits(repo)` - Get all commits (first release)
- `get_commit_shas_by_path(previous_tag, current_tag, paths)` - Get commit SHAs filtered by path using git CLI
- `split_commits_by_path(commits, previous_tag, current_tag, application_paths)` - Split commits into application and other

#### Phase 2: Conventional Commits Parser (`parser.py`)
- `parse_commit_message(message)` - Parse Conventional Commits format
- `categorize_commit(commit)` - Categorize by type (feat, fix, breaking, etc.)
- `is_breaking_change(commit)` - Detect breaking changes
- `extract_scope_and_subject(message)` - Extract scope and subject

#### Phase 3: Markdown Formatter (`formatter.py`)
- `format_release_notes(commits, previous_tag, current_tag, application_commits, other_commits)` - Main formatter that generates Markdown with Application/Other sections
- `group_by_type(commits)` - Group commits by Conventional Commits type (feat, fix, breaking, etc.)
- `format_commit_entry(commit)` - Format individual commit with links and metadata
- `generate_markdown(commits, previous_tag, current_tag, application_commits, other_commits, installation_section=True)` - Generate full Markdown document with Application and Other sections
- `format_section_header(type, emoji)` - Create formatted section headers
- `format_breaking_changes(commits)` - Special formatting for breaking changes
- `add_installation_section()` - Add installation instructions with download links

**Markdown Output Format:**
The formatter will generate rich Markdown with:
- Structured sections with emoji indicators (‚ú® Features, üêõ Bug Fixes, üí• Breaking Changes, etc.)
- Commit links to GitHub
- Author attribution
- Grouped by Conventional Commits type
- Installation section with platform-specific download links
- Proper Markdown formatting (headings, lists, links, code blocks)

#### Phase 4: Main Entry Point (`__main__.py`)
- Parse environment variables (`GITHUB_TOKEN`, `GITHUB_REPOSITORY`, `GITHUB_REF_NAME`)
- Initialize GitHub client
- Get tags and commits
- Parse and format release notes
- Write to `GITHUB_OUTPUT` and `release_notes.md`

### Workflow Integration

**Updated workflow step:**
```yaml
- name: Checkout code
  uses: actions/checkout@...
  with:
    ref: ${{ github.ref }}
    fetch-depth: 0  # Full history needed for git rev-list path filtering

- name: Install uv
  uses: astral-sh/setup-uv@...

- name: Generate release notes
  id: release_notes
  env:
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    GITHUB_REPOSITORY: ${{ github.repository }}
    GITHUB_REF_NAME: ${{ github.ref_name }}
  run: |
    cd .github/scripts/release-notes
    uv run python -m release_notes
```

**Benefits:**
- **Path filtering**: Uses git CLI to filter commits by path (e.g., `src/`, `Cargo.toml`, `Cargo.lock`)
- **Application/Other split**: Clear separation between application changes and other changes
- **Consistency**: Matches `release-version` workflow logic for determining application commits
- Cleaner, more maintainable code
- Better error handling
- Testable components
- **Rich Markdown formatting** with categorized sections, links, and metadata
- **Extensible formatting** - easy to enhance with emojis, badges, tables, etc.
- Professional-looking release notes that are easy to read and navigate

## Implementation Steps

1. **Create Python Project**: Initialize `release-notes` project with `uv` in `.github/scripts/release-notes/`
2. **Implement Core Modules**:
   - Start with `git.py` for tag/commit operations using PyGitHub
   - Implement `get_tags_sorted()` to get tags sorted by semantic version
   - Implement `get_previous_tag()` to correctly identify the previous tag
   - Implement `get_commits_between_tags()` to get commits between tags
3. **Add Conventional Commits Parser**: Implement `parser.py` for commit message parsing
4. **Create Markdown Formatter**: Implement `formatter.py` to generate rich Markdown release notes with:
   - Categorized sections (Features, Bug Fixes, Breaking Changes, etc.)
   - Commit links and author attribution
   - Emoji indicators for visual appeal
   - Installation section with download links
   - Professional formatting that's easy to read
5. **Write Tests**: Add comprehensive tests for all modules using pytest
6. **Update Workflow**: Replace bash script with Python application call
7. **Update Checkout**: Update checkout step to use `fetch-depth: 0` (needed for git rev-list path filtering)
8. **Test in CI**: Verify the solution works in actual workflow runs

## Affected Files

### Current Files (to be modified)
- `.github/workflows/release-build.yaml` (lines 180-212) - Replace bash script with Python application call

### New Files (to be created)
- `.github/scripts/release-notes/pyproject.toml` - Project configuration
- `.github/scripts/release-notes/src/release_notes/__init__.py` - Package init
- `.github/scripts/release-notes/src/release_notes/__main__.py` - Entry point
- `.github/scripts/release-notes/src/release_notes/git.py` - Git operations via PyGitHub
- `.github/scripts/release-notes/src/release_notes/parser.py` - Conventional Commits parser
- `.github/scripts/release-notes/src/release_notes/formatter.py` - Markdown release notes formatter
- `.github/scripts/release-notes/tests/__init__.py` - Test package init
- `.github/scripts/release-notes/tests/conftest.py` - Pytest configuration
- `.github/scripts/release-notes/tests/test_git.py` - Git operations tests
- `.github/scripts/release-notes/tests/test_parser.py` - Parser tests
- `.github/scripts/release-notes/tests/test_formatter.py` - Formatter tests

## References

### Git Documentation
- [Git describe documentation](https://git-scm.com/docs/git-describe)
- [Git tag documentation](https://git-scm.com/docs/git-tag)

### GitHub Actions
- [GitHub Actions context variables](https://docs.github.com/en/actions/learn-github-actions/contexts#github-context)
- [GitHub Actions checkout action](https://github.com/actions/checkout)

### Python Tools
- [PyGitHub documentation](https://pygithub.readthedocs.io/)
- [PyGitHub Repository API](https://pygithub.readthedocs.io/en/latest/github_objects/Repository.html)
- [uv documentation](https://github.com/astral-sh/uv)
- [Conventional Commits specification](https://www.conventionalcommits.org/)

### Related Projects
- `.github/scripts/release-version/` - Similar Python application pattern

## Example: Fancy Markdown Release Notes

Here's an example of what the generated Markdown release notes could look like:

```markdown
# Release v1.2.0

## üéâ What's New

### üì¶ Application

### ‚ú® Features
- Add support for custom output formats ([`abc123`](https://github.com/owner/repo/commit/abc123)) by @username
- Implement caching for improved performance ([`def456`](https://github.com/owner/repo/commit/def456)) by @contributor

### üêõ Bug Fixes
- Fix issue with tag comparison logic ([`ghi789`](https://github.com/owner/repo/commit/ghi789)) by @developer
- Resolve memory leak in parser ([`jkl012`](https://github.com/owner/repo/commit/jkl012)) by @maintainer

### üí• Breaking Changes
- **API Change**: Rename `process()` to `process_file()` ([`mno345`](https://github.com/owner/repo/commit/mno345)) by @author
  - Migration guide: Update all calls to use the new method name

### üîß Other

### üìö Documentation
- Update README with installation instructions ([`pqr678`](https://github.com/owner/repo/commit/pqr678)) by @writer

### üîß Maintenance
- Update dependencies to latest versions ([`stu901`](https://github.com/owner/repo/commit/stu901)) by @maintainer

## üì¶ Installation

Download the appropriate binary for your platform:

- **Linux (x86_64)**: [`move_maker-linux-x86_64`](https://github.com/owner/repo/releases/download/v1.2.0/move_maker-linux-x86_64)
- **Linux (ARM64)**: [`move_maker-linux-aarch64`](https://github.com/owner/repo/releases/download/v1.2.0/move_maker-linux-aarch64)
- **macOS (Intel)**: [`move_maker-macos-x86_64`](https://github.com/owner/repo/releases/download/v1.2.0/move_maker-macos-x86_64)
- **macOS (Apple Silicon)**: [`move_maker-macos-aarch64`](https://github.com/owner/repo/releases/download/v1.2.0/move_maker-macos-aarch64)

## üìä Statistics

- **Total Commits**: 6
- **Application Commits**: 5
- **Other Commits**: 1
- **Contributors**: 4
- **Changes Since**: v1.1.0

---

**Full Changelog**: [`v1.1.0...v1.2.0`](https://github.com/owner/repo/compare/v1.1.0...v1.2.0)
```

This format provides:
- **Application/Other split**: Clear separation between application code changes and other changes (docs, workflows, etc.)
- **Visual appeal** with emoji indicators
- **Easy navigation** with categorized sections within each main section
- **Rich metadata** with commit links and author attribution
- **Professional presentation** suitable for GitHub releases
- **Consistent logic**: Matches `release-version` workflow path filtering (`src/`, `Cargo.toml`, `Cargo.lock`)
- **Extensibility** for future enhancements (badges, tables, graphs, etc.)

## Status

‚úÖ **COMPLETED** - Implementation complete, all tests passing, ready for CI testing

## Implementation Plan

### Phase 1: Project Setup

#### Step 1: Initialize Python project

1. **Create project structure**
   - [x] Navigate to `.github/scripts` directory
   - [x] Initialize new `uv` project: `uv init release-notes`
   - [x] Verify project structure is created correctly
   - [x] Verify `pyproject.toml` is created with basic configuration

2. **Add dependencies**
   - [x] Add core dependencies: `uv add pygithub packaging`
   - [x] Add development dependencies: `uv add --dev pytest pytest-datadir`
   - [x] Verify `uv.lock` file is generated
   - [x] Verify all dependencies are listed in `pyproject.toml`

3. **Configure project metadata**
   - [x] Update `pyproject.toml` with project name: `release-notes`
   - [x] Set `requires-python = ">=3.11"`
   - [x] Configure pytest settings in `pyproject.toml`
   - [x] Verify project structure matches specification

#### Step 2: Create package structure

1. **Create source package**
   - [x] Create `src/release_notes/` directory
   - [x] Create `src/release_notes/__init__.py` (empty file)
   - [x] Create `src/release_notes/__main__.py` (entry point stub)
   - [x] Create `src/release_notes/git.py` (empty file)
   - [x] Create `src/release_notes/parser.py` (empty file)
   - [x] Create `src/release_notes/formatter.py` (empty file)

2. **Create test structure**
   - [x] Create `tests/` directory
   - [x] Create `tests/__init__.py` (empty file)
   - [x] Create `tests/conftest.py` (pytest configuration)
   - [x] Create `tests/test_git.py` (empty file)
   - [x] Create `tests/test_parser.py` (empty file)
   - [x] Create `tests/test_formatter.py` (empty file)

3. **Verify package structure**
   - [x] Verify all files are in correct locations
   - [x] Test package import: `uv run python -c "import release_notes"`
   - [x] Verify pytest can discover tests: `uv run pytest --collect-only`

### Phase 2: Core Git Operations

#### Step 3: Implement git.py module

1. **Implement tag operations**
   - [x] Implement `get_tags_sorted(repo)` function
     - Get all tags from repository using `repo.get_tags()`
     - Sort tags by semantic version using `packaging.version.parse()`
     - Handle tags with and without 'v' prefix
     - Return sorted list (descending: newest first)
   - [x] Add error handling for invalid version tags
   - [x] Add docstrings and type hints

2. **Implement previous tag lookup**
   - [x] Implement `get_previous_tag(repo, current_tag_name)` function
     - Get sorted tags using `get_tags_sorted()`
     - Find current tag in sorted list
     - Return previous tag (next in sorted list) or `None` if first tag
     - Handle case where current tag is not found
   - [x] Add error handling for edge cases
   - [x] Add docstrings and type hints

3. **Implement commit retrieval**
   - [x] Implement `get_commits_between_tags(repo, previous_tag, current_tag)` function
     - Use `repo.compare(previous_tag.commit.sha, current_tag.commit.sha)`
     - Return list of commit objects
     - Handle case where tags point to same commit
   - [x] Implement `get_all_commits(repo)` function for first release
     - Get all commits from repository
     - Filter out merge commits if needed
     - Return list of commit objects
   - [x] Add error handling for API failures
   - [x] Add docstrings and type hints

4. **Implement path filtering**
   - [x] Implement `get_commit_shas_by_path(previous_tag, current_tag, paths)` function
     - Use git CLI `rev-list` command with path filtering
     - Return set of commit SHAs that modify specified paths
     - Handle first release scenario (no previous tag)
     - Handle errors gracefully (return empty set)
   - [x] Implement `split_commits_by_path(commits, previous_tag, current_tag, application_paths)` function
     - Split commits into application and other based on path filtering
     - Use `get_commit_shas_by_path()` to identify application commits
     - Return tuple of (application_commits, other_commits)
     - Default application paths: `["src/", "Cargo.toml", "Cargo.lock"]`
   - [x] Add docstrings and type hints

5. **Write tests for git.py**
   - [x] Write tests for `get_tags_sorted()` with mock repository
   - [x] Write tests for `get_previous_tag()` with various scenarios
   - [x] Write tests for `get_commits_between_tags()` with mock comparison
   - [x] Write tests for `get_all_commits()` with mock repository
   - [x] Write tests for `get_commit_shas_by_path()` with various scenarios
   - [x] Write tests for `split_commits_by_path()` with various scenarios
   - [x] Test error handling and edge cases
   - [x] Verify all tests pass: `uv run pytest tests/test_git.py -v`

### Phase 3: Conventional Commits Parser

#### Step 4: Implement parser.py module

1. **Implement commit message parsing**
   - [x] Implement `parse_commit_message(message)` function
     - Parse Conventional Commits format: `type(scope): subject`
     - Extract type, scope, and subject
     - Handle optional body and footer
     - Return structured data (dict or dataclass)
   - [x] Handle commits without Conventional Commits format (fallback)
   - [x] Add docstrings and type hints

2. **Implement commit categorization**
   - [x] Implement `categorize_commit(commit)` function
     - Map commit types to categories (feat, fix, docs, style, refactor, perf, test, chore, etc.)
     - Handle breaking changes indicator (`!` or `BREAKING CHANGE:`)
     - Return category string
   - [x] Implement `is_breaking_change(commit)` function
     - Check for `!` in type or `BREAKING CHANGE:` in footer
     - Return boolean
   - [x] Implement `extract_scope_and_subject(message)` function
     - Extract scope from parentheses
     - Extract subject after colon
     - Return tuple (scope, subject)
   - [x] Add docstrings and type hints

3. **Write tests for parser.py**
   - [x] Write tests for `parse_commit_message()` with various formats
   - [x] Write tests for `categorize_commit()` with different types
   - [x] Write tests for `is_breaking_change()` with various indicators
   - [x] Write tests for `extract_scope_and_subject()` with different formats
   - [x] Test edge cases (missing scope, missing type, invalid format)
   - [x] Verify all tests pass: `uv run pytest tests/test_parser.py -v`

### Phase 4: Markdown Formatter

#### Step 5: Implement formatter.py module

1. **Implement commit grouping**
   - [x] Implement `group_by_type(commits)` function
     - Group commits by Conventional Commits type
     - Separate breaking changes into their own group
     - Return dictionary mapping types to commit lists
   - [x] Add docstrings and type hints

2. **Implement commit formatting**
   - [x] Implement `format_commit_entry(commit)` function
     - Format individual commit with:
       - Commit message subject
       - Commit SHA link to GitHub
       - Author attribution (if available)
     - Return formatted string
   - [x] Implement `format_section_header(type, emoji)` function
     - Create formatted section headers with emoji
     - Map types to appropriate emojis (‚ú® feat, üêõ fix, üí• breaking, etc.)
     - Return formatted header string
   - [x] Implement `format_breaking_changes(commits)` function
     - Special formatting for breaking changes
     - Include migration notes if available in commit body
     - Return formatted string
   - [x] Add docstrings and type hints

3. **Implement markdown generation**
   - [x] Implement `generate_markdown(commits, previous_tag, current_tag, application_commits, other_commits, installation_section=True)` function
     - Generate main release notes header
     - Split into "Application" and "Other" sections
     - Group commits by type within each section
     - Format each section with headers and commit entries
     - Add installation section with download links (if enabled)
     - Add statistics section (total commits, application commits, other commits, contributors, etc.)
     - Add full changelog link
     - Return complete Markdown string
   - [x] Implement `add_installation_section(current_tag)` function
     - Generate installation section with platform-specific download links
     - Include links for all supported platforms
     - Return formatted Markdown string
   - [x] Add docstrings and type hints

4. **Write tests for formatter.py**
   - [x] Write tests for `group_by_type()` with various commit types
   - [x] Write tests for `format_commit_entry()` with mock commits
   - [x] Write tests for `format_section_header()` with different types
   - [x] Write tests for `format_breaking_changes()` with breaking commits
   - [x] Write tests for `generate_markdown()` with full commit lists
   - [x] Write tests for `add_installation_section()` with different tags
   - [x] Test edge cases (empty commits, single commit, all same type)
   - [x] Verify all tests pass: `uv run pytest tests/test_formatter.py -v`

### Phase 5: Main Entry Point

#### Step 6: Implement __main__.py

1. **Implement environment variable parsing**
   - [x] Parse `GITHUB_TOKEN` from environment (required)
   - [x] Parse `GITHUB_REPOSITORY` from environment (required, format: `owner/repo`)
   - [x] Parse `GITHUB_REF_NAME` from environment (required, tag name)
   - [x] Add error handling for missing environment variables
   - [x] Add helpful error messages

2. **Implement GitHub client initialization**
   - [x] Create GitHub client using `Github(Auth.Token(GITHUB_TOKEN))`
   - [x] Get repository object using `github.get_repo(GITHUB_REPOSITORY)`
   - [x] Add error handling for authentication failures
   - [x] Add error handling for repository not found

3. **Implement main logic**
   - [x] Get current tag from `GITHUB_REF_NAME`
   - [x] Get sorted tags using `get_tags_sorted()`
   - [x] Get previous tag using `get_previous_tag()`
   - [x] Get commits:
     - If previous tag exists: use `get_commits_between_tags()`
     - If no previous tag: use `get_all_commits()`
   - [x] Split commits into application and other using `split_commits_by_path()`
     - Use application paths: `["src/", "Cargo.toml", "Cargo.lock"]`
   - [x] Parse commits using parser functions
   - [x] Generate Markdown using `generate_markdown()` with application/other splits
   - [x] Add error handling for each step

4. **Implement output generation**
   - [x] Write release notes to `GITHUB_OUTPUT`:
     - Set `release_notes` output variable
     - Use proper GitHub Actions output format
   - [x] Write release notes to `release_notes.md` file
   - [x] Add error handling for file write failures

5. **Add logging and error handling**
   - [x] Add logging for debugging (use Python `logging` module)
   - [x] Add try-except blocks for error handling
   - [x] Exit with appropriate exit codes (0 for success, 1 for failure)
   - [x] Add helpful error messages for common failures

6. **Write tests for __main__.py**
   - [x] Write tests with mocked environment variables
   - [x] Write tests with mocked GitHub client
   - [x] Test error handling for missing environment variables
   - [x] Test error handling for API failures
   - [x] Test output generation (GITHUB_OUTPUT and file)
   - [x] Verify all tests pass: `uv run pytest tests/ -v`

### Phase 6: Workflow Integration

#### Step 7: Update release-build.yaml workflow

1. **Update checkout step**
   - [x] Change `fetch-depth` from `1` to `0` (needed for git rev-list path filtering)
   - [x] Verify checkout step still works correctly
   - [x] Test that full history is available for git CLI path filtering

2. **Replace release notes generation step**
   - [x] Remove old bash script (lines 182-214)
   - [x] Add new step: "Generate release notes"
   - [x] Set step `id: release_notes`
   - [x] Add environment variables:
     - `GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}`
     - `GITHUB_REPOSITORY: ${{ github.repository }}`
     - `GITHUB_REF_NAME: ${{ github.ref_name }}`
   - [x] Add run command:
     ```yaml
     run: |
       cd .github/scripts/release-notes
       uv run python -m release_notes
     ```
   - [x] Verify step placement is correct (after checkout, before release creation)

3. **Update release creation step**
   - [x] Verify release creation step uses `${{ steps.release_notes.outputs.release_notes }}`
   - [x] Or update to read from `release_notes.md` file if needed
   - [x] Verify release notes are passed correctly to `gh release create`

4. **Validate YAML syntax**
   - [x] Use YAML linter to validate workflow file
   - [x] Verify indentation is correct
   - [x] Verify no syntax errors
   - [x] Verify step names are unique

### Phase 7: Testing

#### Step 8: Local testing

1. **Test Python application locally**
   - [ ] Set up test environment variables:
     ```bash
     export GITHUB_TOKEN="your_token"
     export GITHUB_REPOSITORY="owner/repo"
     export GITHUB_REF_NAME="v1.0.0"
     ```
   - [ ] Run application: `cd .github/scripts/release-notes && uv run python -m release_notes`
   - [ ] Verify release notes are generated correctly
   - [ ] Verify `release_notes.md` file is created
   - [ ] Verify output format matches expected Markdown structure
   - [ ] Test with different tag scenarios:
     - First release (no previous tag)
     - Second release (one previous tag)
     - Multiple tags (several previous tags)

2. **Test with mock GitHub API**
   - [ ] Create mock repository with test tags and commits
   - [ ] Test application with mock data
   - [ ] Verify all functions work correctly
   - [ ] Test error handling with invalid data

3. **Run all tests**
   - [ ] Run full test suite: `uv run pytest tests/ -v`
   - [ ] Verify all tests pass
   - [ ] Check test coverage (if configured)
   - [ ] Fix any failing tests

#### Step 9: CI verification

1. **Test with test tag**
   - [ ] Create a test tag (e.g., `v0.0.0-test`)
   - [ ] Push tag to trigger release-build workflow
   - [ ] Verify workflow completes successfully
   - [ ] Verify "Generate release notes" step completes
   - [ ] Verify release notes are generated correctly
   - [ ] Verify release notes are included in GitHub release
   - [ ] Verify release notes format matches expected structure
   - [ ] Delete test tag after verification

2. **Test first release scenario**
   - [ ] (If possible) Test with repository that has no tags
   - [ ] Create first tag and trigger workflow
   - [ ] Verify all commits are included in release notes
   - [ ] Verify format is correct for first release

3. **Test subsequent release scenario**
   - [ ] Create second test tag (e.g., `v0.0.1-test`)
   - [ ] Push tag to trigger workflow
   - [ ] Verify commits between tags are included
   - [ ] Verify previous tag is correctly identified
   - [ ] Verify release notes format is correct
   - [ ] Delete test tag after verification

4. **Verify release notes quality**
   - [ ] Check that commits are categorized correctly
   - [ ] Check that breaking changes are highlighted
   - [ ] Check that commit links work correctly
   - [ ] Check that author attribution is included
   - [ ] Check that installation section is included
   - [ ] Check that statistics are accurate

### Implementation Order

1. [x] Phase 1, Step 1: Initialize Python project with `uv`
2. [x] Phase 1, Step 2: Create package structure
3. [x] Phase 2, Step 3: Implement `git.py` module
4. [x] Phase 2, Step 3: Write tests for `git.py`
5. [x] Phase 3, Step 4: Implement `parser.py` module
6. [x] Phase 3, Step 4: Write tests for `parser.py`
7. [x] Phase 4, Step 5: Implement `formatter.py` module
8. [x] Phase 4, Step 5: Write tests for `formatter.py`
9. [x] Phase 5, Step 6: Implement `__main__.py` entry point
10. [x] Phase 5, Step 6: Write tests for `__main__.py`
11. [x] Phase 6, Step 7: Update `release-build.yaml` workflow
12. [ ] Phase 7, Step 8: Test Python application locally
13. [x] Phase 7, Step 8: Run all tests and verify coverage
14. [ ] Phase 7, Step 9: Test with test tag in CI
15. [ ] Phase 7, Step 9: Test first release scenario
16. [ ] Phase 7, Step 9: Test subsequent release scenario
17. [ ] Phase 7, Step 9: Verify release notes quality
18. [ ] Clean up test tags
19. [ ] Merge changes to main branch
20. [ ] Verify production workflow runs with real release tag

### Risk Assessment

- **Risk Level:** Medium
- **Impact if Failed:**
  - Release notes generation could fail if PyGitHub API calls fail
  - Release notes might be empty or incorrect if tag comparison logic is wrong
  - Workflow might fail if Python application has errors
  - Release creation could fail if release notes format is invalid
  - GitHub API rate limits could be exceeded (unlikely with Actions token)
- **Mitigation:**
  - Comprehensive test coverage for all modules
  - Error handling at each step with helpful error messages
  - Local testing before CI deployment
  - Test with test tags before affecting production releases
  - PyGitHub handles rate limiting automatically
  - Can rollback by reverting workflow changes
  - Can fallback to simple bash script if needed
- **Testing:**
  - Can be fully tested locally with mock data
  - Can test with test tags before production
  - Unit tests for all modules
  - Integration tests for full workflow
  - Can verify output format before deployment
- **Dependencies:**
  - `uv` must be available in GitHub Actions (can install if needed)
  - `pygithub` requires Python 3.11+ (GitHub Actions runners support this)
  - `packaging` for version parsing (standard library alternative exists)
  - GitHub Actions token must have repository read access (default `GITHUB_TOKEN` has this)
  - No additional system dependencies required
- **Performance Considerations:**
  - PyGitHub API calls are fast (< 1 second per call)
  - Total execution time should be < 10 seconds
  - No heavy computation or file I/O
  - Can cache tag list if needed (future optimization)
  - Shallow clone (`fetch-depth: 1`) reduces checkout time
- **Benefits:**
  - Fixes tag comparison bug (main goal)
  - Rich Markdown formatting improves release notes quality
  - Categorized sections make release notes easier to read
  - Commit links and author attribution provide better context
  - Extensible architecture allows future enhancements
  - Testable code improves maintainability
  - Consistent with existing `release-version` pattern

### Expected Outcomes

After successful implementation:

- **Tag Comparison Fixed:** Release notes correctly show commits between previous tag and current tag
- **Rich Markdown Format:** Release notes are well-formatted with categorized sections, emojis, and links
- **Better User Experience:** Release notes are easier to read and navigate
- **Professional Presentation:** Release notes look professional and suitable for GitHub releases
- **Improved Maintainability:** Python code is easier to maintain and extend than bash scripts
- **Better Testing:** Comprehensive test coverage ensures reliability
- **Performance Improvement:** Shallow clone reduces checkout time (no need for `fetch-depth: 0`)
- **Extensibility:** Easy to add new features (badges, tables, graphs, etc.)
- **Consistency:** Follows same pattern as `release-version` application
- **Documentation:** Well-documented code with docstrings and type hints
- **Error Handling:** Clear error messages help with debugging
- **GitHub Integration:** Direct links to commits, PRs, and issues improve navigation
